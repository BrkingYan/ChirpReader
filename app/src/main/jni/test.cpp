/* DO NOT EDIT THIS FILE - it is machine generated */
#include "jni.h"
#include <math.h>
#include <stdio.h>
#include <string.h>
#include <stdlib.h>
#include "fftsg_h_float.c"
/* Header for class com_example_yy_chiprreader_utils_Algorithm */

#ifndef _Included_com_example_yy_chiprreader_utils_Algorithm
#define _Included_com_example_yy_chiprreader_utils_Algorithm
#ifdef __cplusplus
extern "C" {
#endif



int main()
{
	double arr[8];
	int ip[6];
	double w[6];

	arr[0] = 1;
	arr[1] = 0;
	arr[2] = 2;
	arr[3] = 0;
	arr[4] = -1;
	arr[5] = 0;
	arr[6] = 3;
	arr[7] = 0;

	//cdft(8,-1,arr,ip,w);
	printf("%f",arr[6]);
	return 0;
}

    /*
     * Class:     com_example_yy_chiprreader_utils_Algorithm
     * Method:    correlationJni
     * Signature: ([D[D)[D
     */
    JNIEXPORT jfloat JNICALL Java_com_example_yy_chiprreader_utils_Algorithm_correlationJni
      (JNIEnv *env, jclass clazz, jfloatArray s1, jfloatArray s2)
      {
                    jfloat* s1P = env->GetFloatArrayElements(s1,0);
                    jfloat* s2P = env->GetFloatArrayElements(s2,0);
                    jint len1 = env->GetArrayLength(s1);
                    jint len2 = env->GetArrayLength(s2);

                    jfloat* outputP = new jfloat[len1+len2-1];

                    int delay,i,j;
                    float sxy;
                    float max;
                    int maxIndex;

                    delay = -len1+1;
                    sxy = 0;

                    for(i = 0;i<len1;i++)
                    {
                        j = i + delay;
                        if((j<0) || (j >= len2))
                        {
                            continue;
                        }
                        else
                        {
                            sxy += (s1P[i]*s2P[j]);
                        }
                    }

                    outputP[delay+len1-1] = sxy;
                    max = sxy;
                    maxIndex = delay + len1 - 1;

                    for(delay = -len1+2;delay<len2;delay++)
                    {
                        sxy = 0;
                        for(i = 0;i<len1;i++)
                        {
                            j = i + delay;
                            if((j<0) || (j>=len2))
                            {
                                continue;
                            }
                            else
                            {
                                sxy += (s1P[i] * s2P[j]);
                            }
                        }
                        outputP[delay+len1-1] = sxy;

                        if(outputP[delay+len1-1] > max)
                        {
                            max = outputP[delay+len1-1];
                            maxIndex = delay+len1-1;
                        }
                    }

                    //jdoubleArray ret = env->NewDoubleArray(len1+len2-1);
                    //env->SetDoubleArrayRegion(ret,0,len1+len2-1,outputP);

                    delete [] outputP;
                    env->ReleaseFloatArrayElements(s1,s1P,0);
                    env->ReleaseFloatArrayElements(s2,s2P,0);

                    return max;
       }

       /*
        * Class:     com_example_yy_chiprreader_utils_Algorithm
        * Method:    correlationJni2
        * Signature: ([S[S)F
        */
       JNIEXPORT jint JNICALL Java_com_example_yy_chiprreader_utils_Algorithm_correlationJni2
         (JNIEnv *env, jclass clazz, jshortArray s1, jshortArray s2)
         {
                                jshort* s1P = env->GetShortArrayElements(s1,0);
                                jshort* s2P = env->GetShortArrayElements(s2,0);
                                jint len1 = env->GetArrayLength(s1);
                                jint len2 = env->GetArrayLength(s2);

                                jint* outputP = new jint[len1+len2-1];

                                int delay,i,j;
                                int sxy;
                                int max;
                                int maxIndex;

                                delay = -len1+1;
                                sxy = 0;

                                for(i = 0;i<len1;i++)
                                {
                                    j = i + delay;
                                    if((j<0) || (j >= len2))
                                    {
                                        continue;
                                    }
                                    else
                                    {
                                        sxy += (s1P[i]*s2P[j]);
                                    }
                                }

                                outputP[delay+len1-1] = sxy;
                                max = sxy;
                                maxIndex = delay + len1 - 1;

                                for(delay = -len1+2;delay<len2;delay++)
                                {
                                    sxy = 0;
                                    for(i = 0;i<len1;i++)
                                    {
                                        j = i + delay;
                                        if((j<0) || (j>=len2))
                                        {
                                            continue;
                                        }
                                        else
                                        {
                                            sxy += (s1P[i] * s2P[j]);
                                        }
                                    }
                                    outputP[delay+len1-1] = sxy;

                                    if(outputP[delay+len1-1] > max)
                                    {
                                        max = outputP[delay+len1-1];
                                        maxIndex = delay+len1-1;
                                    }
                                }

                                //jintArray ret = env->NewIntArray(len1+len2-1);
                               // env->SetIntArrayRegion(ret,0,len1+len2-1,outputP);
                                delete [] outputP;
                                env->ReleaseShortArrayElements(s1,s1P,0);
                                env->ReleaseShortArrayElements(s2,s2P,0);

                               // if(max <33000)
                               // {
                                //    return -1;
                               // }
                              //  else
                                //{
                                int ress = maxIndex-len1+1;
                                if(abs(ress) > 100)
                                {
                                    return -1;
                                }
                                else
                                {
                                    return ress;
                                }

                               // }
         }

/*
 * Class:     com_example_yy_chiprreader_utils_Algorithm
 * Method:    mixFrequenceJni
 * Signature: ([D[D)[D
 */
JNIEXPORT jfloatArray JNICALL Java_com_example_yy_chiprreader_utils_Algorithm_mixFrequenceJni
  (JNIEnv *env, jclass clazz, jfloatArray a, jfloatArray b)
  {
          int len = env->GetArrayLength(a);
          	jfloatArray c = env->NewFloatArray(len);
          	jfloat* cP = env->GetFloatArrayElements(c,0);
          	jfloat* aP = env->GetFloatArrayElements(a,0);
          	jfloat* bP = env->GetFloatArrayElements(b,0);

          	for(int i = 0;i<len;i++)
          	{
          		cP[i] = aP[i] * bP[i];
          	}
          	env->ReleaseFloatArrayElements(c,cP,0);
              env->ReleaseFloatArrayElements(a,aP,0);
              env->ReleaseFloatArrayElements(b,bP,0);

          	return c;
    }

    /*
     * Class:     com_example_yy_chiprreader_utils_Algorithm
     * Method:    mixAndSumJni
     * Signature: ([D[D)D
     */
    JNIEXPORT jfloat JNICALL Java_com_example_yy_chiprreader_utils_Algorithm_mixAndSumJni
      (JNIEnv *env, jclass clazz, jfloatArray a, jfloatArray b)
      {
            int len = env->GetArrayLength(a);
            float sum = 0;
                      	jfloat* aP = env->GetFloatArrayElements(a,0);
                      	jfloat* bP = env->GetFloatArrayElements(b,0);

                      	for(int i = 0;i<len;i++)
                      	{
                      		sum += (aP[i] * bP[i]);
                      	}
                          env->ReleaseFloatArrayElements(a,aP,0);
                          env->ReleaseFloatArrayElements(b,bP,0);

                      	return sum;
      }

/*
 * Class:     com_example_yy_chiprreader_utils_Algorithm
 * Method:    fftJni
 * Signature: ([D)[D
 */
 int N_FFT = 4;
JNIEXPORT jfloatArray JNICALL Java_com_example_yy_chiprreader_utils_Algorithm_fftJni
  (JNIEnv *env, jclass clazz, jfloatArray signal,jint len)
  {
        jfloat *signalP = env->GetFloatArrayElements(signal,0);
        jsize n = env->GetArrayLength(signal);
        int l = 1;
        while(l < len)
        {
            l = l * 2;
        }

        jfloat * sig = new jfloat[2*l];
        for(int i = 0;i<l;i++)
        {
            if(i < n)
            {
                sig[2*i] = signalP[i];
                sig[2*i+1] = 0;
            }else
            {
                sig[2*i] = 0;
                sig[2*i+1] = 0;
            }
        }

        cdft(2*l,-1,sig);
        jfloatArray output = env->NewFloatArray(2*l);
        env->SetFloatArrayRegion(output,0,2*l,sig);
        env->ReleaseFloatArrayElements(signal,signalP,0);

        jfloatArray result = env->NewFloatArray(l);
        jfloat * resultP = env->GetFloatArrayElements(result,0);
        for(int i = 0;i<l;i++)
        {
            resultP[i] = sqrt(sig[2*i]*sig[2*i] + sig[2*i+1]*sig[2*i+1]);
        }
        env->ReleaseFloatArrayElements(result,resultP,0);
        return result;
  /*
                jint signalLen = env->GetArrayLength(signal);

                	//printf("signalLen:%d\n",signalLen);
                	//jdouble* signalP = env->GetDoubleArrayElements(signal,0);//1
                	jint len = N_FFT;

                	jdouble* signalP = env->GetDoubleArrayElements(signal,0);
                	jdoubleArray proSignal = env->NewDoubleArray(len);
                	jdouble* proSigP = env->GetDoubleArrayElements(proSignal,0);//2

                	//拷贝signal前面的元素
                	for(int i = 0;i<signalLen;i++)
                	{
                		proSigP[i] = signalP[i];
                		//printf("proSig[%d] = %f\n",i,proSigP[i]);
                	}

                	//对signal后面的元素补零，从480补到65536
                	for(int i = signalLen;i<len;i++)
                	{
                		proSigP[i] = 0;
                		//printf("proSig[%d] = %f\n",i,proSigP[i]);
                	}

                	jdoubleArray result = env->NewDoubleArray(2 * len);
                	jdouble* resultP = env->GetDoubleArrayElements(result,0);//3

                	//偶数位为实部，奇数位为虚部，为0,len = 65536
                	for(int i = 0;i<len;i++)
                	{
                		resultP[2*i] = proSigP[i];
                		resultP[2*i+1] = 0;
                	}

                	int ip[10];
                	double w[20];

                	cdft(2*len,-1,resultP,ip,w);

                	jdoubleArray ampResult = env->NewDoubleArray(len);
                	jdouble* ampResultP = env->GetDoubleArrayElements(ampResult,0);//4

                	for(int i = 0;i<len;i++)
                	{
                		ampResultP[i] = sqrt(resultP[2*i] * resultP[2*i] + resultP[2*i+1] * resultP[2*i+1]);
                	}

                	env->ReleaseDoubleArrayElements(ampResult,ampResultP,0);
                	return ampResult;*/
      }


/*
    * 归一化函数
    */
    float* normalize(short* arr,int length){
        int len  = length;
        short *arrCopy = (short*)malloc(sizeof(short)*len);
        memcpy(arrCopy,arr,sizeof(short)*len);

        for (int i = 0; i < len; ++i) {
            if (arrCopy[i] < 0){
                arrCopy[i] = - arrCopy[i];
            }
        }

        short max = 0;
        for (int j = 0; j < len; ++j) {
            if (arrCopy[j] > max){
                max = arrCopy[j];
            }
        }
        float *result =  (float*)malloc(sizeof(float)*len);
        for (int k = 0; k < len; ++k) {
            result[k] = (float)arr[k] / max;
        }
        return result;
    }

/*
 * Class:     com_example_yy_chiprreader_utils_Algorithm
 * Method:    normolizeArrayJni
 * Signature: ([S)[D
 */
JNIEXPORT jfloatArray JNICALL Java_com_example_yy_chiprreader_utils_Algorithm_normolizeArrayJni
  (JNIEnv *env, jclass clazz, jshortArray arr)
  {
              jshort* arrP = env->GetShortArrayElements(arr,0);
              int len = env->GetArrayLength(arr);
              jfloatArray result = env->NewFloatArray(len);
              jfloat* resultP = normalize(arrP,len);

              env->ReleaseFloatArrayElements(result,resultP,0);
              env->ReleaseShortArrayElements(arr,arrP,0);

              return result;

        }

#ifdef __cplusplus
}
#endif
#endif
